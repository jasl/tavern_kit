<%# Update the auto-mode toggle button in the group queue %>
<%
  # Controller already reloads @space.space_memberships after disable_all_copilot_modes!
  @conversation.increment!(:group_queue_revision)
  render_seq = @conversation.group_queue_revision

  queue_members = TurnScheduler::Queries::QueuePreview.call(conversation: @conversation, limit: 10)
  active_run = @conversation.conversation_runs.active.includes(:speaker_space_membership).order(
    Arel.sql("CASE status WHEN 'running' THEN 0 WHEN 'queued' THEN 1 ELSE 2 END"),
    created_at: :desc
  ).first
%>

<%= turbo_stream.replace dom_id(@conversation, :group_queue) do %>
  <%= render "messages/group_queue",
             conversation: @conversation,
             space: @space,
             queue_members: queue_members,
             active_run: active_run,
             render_seq: render_seq %>
<% end %>

<%# Update the message form to reflect Copilot state changes (Auto and Copilot are mutually exclusive) %>
<%= turbo_stream.replace "message_form" do %>
  <%= render "messages/form",
             conversation: @conversation,
             space: @space,
             message: @conversation.messages.new %>
<% end %>

<%# Show toast notification %>
<% if @conversation.auto_mode_enabled? %>
  <%= turbo_stream.action :show_toast, nil,
                          partial: "shared/toast",
                          locals: {
                            message: t("conversations.auto_mode.started",
                                       default: "Auto-mode started (%{rounds} rounds)",
                                       rounds: @conversation.auto_mode_remaining_rounds),
                            type: :success
                          } %>
<% else %>
  <%= turbo_stream.action :show_toast, nil,
                          partial: "shared/toast",
                          locals: {
                            message: t("conversations.auto_mode.stopped", default: "Auto-mode stopped"),
                            type: :info
                          } %>
<% end %>
