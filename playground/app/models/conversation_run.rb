# frozen_string_literal: true

# ConversationRun represents an AI response generation task.
#
# Uses a `kind` enum instead of STI for simpler, more explicit behavior.
# Kind determines the type of run:
# - auto_response: AI character responds automatically
# - copilot_response: AI responds as a human user (copilot mode)
# - regenerate: Regenerate an existing message (add swipe)
# - force_talk: Force a specific character to speak
#
# ## Status Lifecycle
#
# queued → running → succeeded/failed/canceled/skipped
#
# ## Concurrency
#
# Database has unique partial indexes ensuring:
# - Only one queued run per conversation
# - Only one running run per conversation
#
class ConversationRun < ApplicationRecord
  STATUSES = %w[queued running succeeded failed canceled skipped].freeze
  KINDS = %w[auto_response copilot_response regenerate force_talk].freeze

  # Safety net timeout - only kills runs that have been stuck for a very long time
  STALE_TIMEOUT = 10.minutes
  STALE_HEARTBEAT_THRESHOLD = 30.seconds

  belongs_to :conversation
  belongs_to :speaker_space_membership, class_name: "SpaceMembership", optional: true

  has_many :messages, dependent: :nullify

  enum :status, STATUSES.index_by(&:itself)
  enum :kind, KINDS.index_by(&:itself)

  validates :status, inclusion: { in: STATUSES }
  validates :kind, inclusion: { in: KINDS }
  validates :reason, presence: true

  scope :queued, -> { where(status: "queued") }
  scope :running, -> { where(status: "running") }
  scope :active, -> { where(status: %w[queued running]) }
  scope :finished, -> { where(status: %w[succeeded failed canceled skipped]) }

  # Kind-specific scopes
  scope :ai_responses, -> { where(kind: %w[auto_response copilot_response force_talk]) }

  # Order by status priority (running > queued > others)
  scope :by_status_priority, -> {
    order(Arel.sql("CASE status WHEN 'running' THEN 0 WHEN 'queued' THEN 1 ELSE 2 END"), created_at: :desc)
  }

  # Kind labels for UI display
  KIND_LABELS = {
    "auto_response" => "Auto Turn",
    "copilot_response" => "Copilot Turn",
    "regenerate" => "Regenerate",
    "force_talk" => "Force Talk",
  }.freeze

  # ============================================================================
  # Status Queries
  # ============================================================================

  def ready_to_run?(now = Time.current)
    run_after.nil? || run_after <= now
  end

  def cancel_requested?
    cancel_requested_at.present?
  end

  def active?
    queued? || running?
  end

  def finished?
    succeeded? || failed? || canceled? || skipped?
  end

  # Can this run be canceled by the user?
  def can_cancel?
    active?
  end

  # Is this run stale (no heartbeat for too long)?
  def stale?(now: Time.current, timeout: STALE_TIMEOUT)
    return false unless running?

    last = heartbeat_at || started_at
    return false unless last

    last < now - timeout
  end

  # ============================================================================
  # Status Transitions
  # ============================================================================

  def request_cancel!(at: Time.current)
    update!(cancel_requested_at: at) unless cancel_requested_at
  end

  def queued!(run_after: nil, **attrs)
    update!({ status: "queued", run_after: run_after }.merge(attrs))
  end

  def running!(at: Time.current, **attrs)
    update!({ status: "running", started_at: at, finished_at: nil, heartbeat_at: at }.merge(attrs))
  end

  def succeeded!(at: Time.current, **attrs)
    update!({ status: "succeeded", finished_at: at }.merge(attrs))
  end

  def failed!(at: Time.current, error: nil, **attrs)
    update!({ status: "failed", finished_at: at, error: (error || {}) }.merge(attrs))
  end

  def canceled!(at: Time.current, **attrs)
    update!({ status: "canceled", finished_at: at }.merge(attrs))
  end

  def skipped!(at: Time.current, **attrs)
    update!({ status: "skipped", finished_at: at }.merge(attrs))
  end

  # Update heartbeat timestamp (called periodically during generation).
  def heartbeat!(at: Time.current)
    return false unless running?

    update_column(:heartbeat_at, at)
    true
  end

  # ============================================================================
  # Kind Helpers
  # ============================================================================

  # Get human-readable label for this run's kind.
  def kind_label
    KIND_LABELS[kind] || kind&.humanize || "Unknown"
  end

  # Alias for backwards compatibility during migration
  alias_method :type_label, :kind_label

  # Is this run an AI-generated response?
  # (auto_response?, copilot_response?, force_talk? are generated by enum)
  def ai_response?
    auto_response? || copilot_response? || force_talk?
  end

  # Note: regenerate? is generated by the enum :kind declaration

  # Should this run be executed (call LLM)?
  # All current run kinds execute LLM calls.
  def should_execute?
    true
  end
end
